<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>html5 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="优化动画、存储、历史记录、worker异步计时器做动画有缺陷，因为js是单线成的，在动画运行前插入一个任务，会完成这个任务后在执行动画，如果执行任务花费的时间长的话就会影响动画效果，所以计时器做动画不是最优的选择，还有计时器需要设置时间，设置的时间也不那么准确的确定动画运行流畅;一般浏览器15-16ms会刷新，设置小了会掉帧；打了有卡顿 requestAnimationFrame 可以弥补计时器缺">
<meta property="og:type" content="article">
<meta property="og:title" content="html5">
<meta property="og:url" content="http://yoursite.com/2018/11/07/html5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="优化动画、存储、历史记录、worker异步计时器做动画有缺陷，因为js是单线成的，在动画运行前插入一个任务，会完成这个任务后在执行动画，如果执行任务花费的时间长的话就会影响动画效果，所以计时器做动画不是最优的选择，还有计时器需要设置时间，设置的时间也不那么准确的确定动画运行流畅;一般浏览器15-16ms会刷新，设置小了会掉帧；打了有卡顿 requestAnimationFrame 可以弥补计时器缺">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2018/11/07/image/h5-raf.png">
<meta property="og:image" content="http://yoursite.com/2018/11/07/image/h5-raf2.png">
<meta property="og:image" content="http://yoursite.com/2018/11/07/image/h5-spa.png">
<meta property="og:image" content="http://yoursite.com/2018/11/07/image/h5-gpos.png">
<meta property="og:image" content="http://yoursite.com/2018/11/07/image/yaoyiyao.png">
<meta property="og:image" content="http://yoursite.com/2018/11/07/image/h5-xyz.png">
<meta property="og:image" content="http://yoursite.com/2018/11/07/image/error.png">
<meta property="og:image" content="http://yoursite.com/2018/11/07/image/drag.png">
<meta property="og:image" content="http://yoursite.com/2018/11/07/image/h5-drop.png">
<meta property="og:image" content="http://yoursite.com/2018/11/07/image/webscoket.png">
<meta property="og:image" content="http://yoursite.com/2018/11/07/image/ws.png">
<meta property="og:image" content="http://yoursite.com/2018/11/07/image/socket1.png">
<meta property="og:updated_time" content="2018-11-14T07:45:08.258Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="html5">
<meta name="twitter:description" content="优化动画、存储、历史记录、worker异步计时器做动画有缺陷，因为js是单线成的，在动画运行前插入一个任务，会完成这个任务后在执行动画，如果执行任务花费的时间长的话就会影响动画效果，所以计时器做动画不是最优的选择，还有计时器需要设置时间，设置的时间也不那么准确的确定动画运行流畅;一般浏览器15-16ms会刷新，设置小了会掉帧；打了有卡顿 requestAnimationFrame 可以弥补计时器缺">
<meta name="twitter:image" content="http://yoursite.com/2018/11/07/image/h5-raf.png">
  
    <link rel="alternate" href="/blog/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
          <a class="main-nav-link" href="/blog/Cultural-and-art">Cultural-and-art</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-html5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018/11/07/html5/" class="article-date">
  <time datetime="2018-11-07T11:51:22.000Z" itemprop="datePublished">2018-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      html5
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="优化动画、存储、历史记录、worker异步"><a href="#优化动画、存储、历史记录、worker异步" class="headerlink" title="优化动画、存储、历史记录、worker异步"></a>优化动画、存储、历史记录、worker异步</h2><h3 id="计时器做动画有缺陷，因为js是单线成的，在动画运行前插入一个任务，会完成这个任务后在执行动画，如果执行任务花费的时间长的话就会影响动画效果，所以计时器做动画不是最优的选择，还有计时器需要设置时间，设置的时间也不那么准确的确定动画运行流畅-一般浏览器15-16ms会刷新，设置小了会掉帧；打了有卡顿"><a href="#计时器做动画有缺陷，因为js是单线成的，在动画运行前插入一个任务，会完成这个任务后在执行动画，如果执行任务花费的时间长的话就会影响动画效果，所以计时器做动画不是最优的选择，还有计时器需要设置时间，设置的时间也不那么准确的确定动画运行流畅-一般浏览器15-16ms会刷新，设置小了会掉帧；打了有卡顿" class="headerlink" title="计时器做动画有缺陷，因为js是单线成的，在动画运行前插入一个任务，会完成这个任务后在执行动画，如果执行任务花费的时间长的话就会影响动画效果，所以计时器做动画不是最优的选择，还有计时器需要设置时间，设置的时间也不那么准确的确定动画运行流畅;一般浏览器15-16ms会刷新，设置小了会掉帧；打了有卡顿"></a>计时器做动画有缺陷，因为js是单线成的，在动画运行前插入一个任务，会完成这个任务后在执行动画，如果执行任务花费的时间长的话就会影响动画效果，所以计时器做动画不是最优的选择，还有计时器需要设置时间，设置的时间也不那么准确的确定动画运行流畅;一般浏览器15-16ms会刷新，设置小了会掉帧；打了有卡顿</h3><ol>
<li><p>requestAnimationFrame 可以弥补计时器缺点；浏览器一刷新就执行</p>
<p> 1) 页面刷新前执行一次</p>
<p> 2) 1000ms 60fps –&gt; 16ms</p>
<p> 3) cancelAnimationFrame</p>
<p> 4) 用法和setTimeout类似</p>
<p> 5) 兼容性 IE10以上;向前兼容用计时器</p>
<p> requestAnimationFrame(f)</p>
<p> cancelAnimationFrame(id)</p>
<p> <img src="../image/h5-raf.png" alt="兼容性写法"><br>  <img src="../image/h5-raf2.png" alt="兼容性写法"></p>
</li>
<li><p>客户端存储</p>
<p> 1) storage</p>
<ul>
<li><p>localstorage</p>
<p>存</p>
<p><code>loaclStorage.name = &#39;aimee&#39;</code></p>
<p><code>loaclStorage.info = JSON.stringify({name:&#39;aimee&#39;,company:&#39;dy&#39;})</code></p>
<p>取出数据</p>
<p><code>localStroage.name</code></p>
<p><code>JSON.parse(localStorage.info)</code></p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2></li>
</ul>
<ol>
<li>setItem(name,val) 设置属性值</li>
<li>getItem(name) 获得属性值</li>
<li>removeItem(name) 移除属性</li>
<li>clear() 清除属性</li>
</ol>
</li>
</ol>
<pre><code>存储的有效期

localStorage --&gt; 永久的，除非手动删除

sessionStorage --&gt; 临时，窗口关闭就没有了

cookie --&gt; 设置有效期，在有效期内存在

作用域

localStorage --&gt; 文档源限制

sessionStorage --&gt; 文档源限制 + 窗口

cookie --&gt;    

+ seesionstorage 

2) cookie

存储信息到用户的设备上，数据量较小

navigator.cookieEnabled

检测是否启用了cookie

+ 设置cookie值：

document.cookie = &quot;name=aimee&quot;

(每次只能设置一个值，因为浏览器会认为后面的键值对是这个cookie的属性)

+ 获得cookie值：

document.cookie

不建议出现分号，逗号，空格的奇怪的符号

encodeURIComponent()

decodeURIComponent()

设置cookie存储期限

1. document.cookie = &quot;name=scott;max-age=1000&quot;
2. expires 当前时间加上保存时间
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var timestamp = (new Date()).getTime() + 10000;</span><br><span class="line">var expires = new Date(timestamp).toGMTString();</span><br><span class="line">document.cookie = &quot;name=scott;expires=&quot;+expires;</span><br></pre></td></tr></table></figure>

3. domain
4. path

删除cookie max-age = 0

需要带上键值对

document.cookie = &quot;name=scott;max-age=0&quot;

expires 设置为之前的时间

document.cookie = &quot;name=scott;expires=...&quot;;
</code></pre><ol start="3">
<li><p>历史记录</p>
</li>
<li><p>worker</p>
</li>
</ol>
<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><ol>
<li>history.back()</li>
<li>history.forward()</li>
<li>history.go(n)</li>
</ol>
<p>为什么要管理历史记录？</p>
<p>history api的作用？</p>
<p>SPA</p>
<p>通过修改hash和hashchange事件来实现历史记录管理</p>
<p>点击导航的时候有链接跳转，就不是单页面应用了；点击导航的时候页面不跳转，只是内容更换</p>
<ol>
<li>pushState</li>
</ol>
<p>history.pushState(state,title,url); 添加一条历史记录</p>
<ol start="2">
<li>replaceState</li>
</ol>
<p>history.replaceState(state,title,url); 替换当前的历史记录</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul>
<li>state： 一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数中。如果不需要这个对象，此处可以填null</li>
<li>title： 新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null</li>
<li>url： 新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ol>
<li>popstate 事件</li>
</ol>
<p>历史记录发生改变时触发</p>
<p>调用history.pushState()或者history.replaceState()不会触发popstate事件</p>
<ol start="2">
<li>hashchange 事件</li>
</ol>
<p>当页面的hash值改变的时候触发，常用于构建单页面应用</p>
<p><img src="../image/h5-spa.png" alt=""></p>
<h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p>var worker = new Worker(‘worker.js’);</p>
<p>worker文件必须和主文件满足同源策略</p>
<h2 id="worker和主线程之间的通信"><a href="#worker和主线程之间的通信" class="headerlink" title="worker和主线程之间的通信"></a>worker和主线程之间的通信</h2><ol>
<li>postMessage(n) 方法</li>
<li>message 事件</li>
</ol>
<p>结束一个worker</p>
<ul>
<li>close() 在worker作用域中调用（worker.js）</li>
<li>terminate() 在worker对象上调用（主进程的worker对象上worker.terminate）</li>
</ul>
<h2 id="worker-其他特性"><a href="#worker-其他特性" class="headerlink" title="worker 其他特性"></a>worker 其他特性</h2><ol>
<li>importScripts(‘./math1.js’,’./math2.js’)</li>
</ol>
<p>worker只是window的子集，只能实现部分功能，不能获取到window，document，所以这里不要引jquery和zepto。可以引入一些计算类的库</p>
<ol start="2">
<li>作用域globalWorkerScope</li>
</ol>
<ul>
<li>可以继续生成worker对象（chrome暂时还不支持，浏览器支持情况不好）</li>
<li>navigator</li>
<li>XMLHttpRequest</li>
<li>setTimeout/serInterval</li>
</ul>
<h2 id="h5地理位置信息、重力感应"><a href="#h5地理位置信息、重力感应" class="headerlink" title="h5地理位置信息、重力感应"></a>h5地理位置信息、重力感应</h2><h2 id="geolocation"><a href="#geolocation" class="headerlink" title="geolocation"></a>geolocation</h2><ul>
<li>window.navigator.geolocation</li>
</ul>
<ol>
<li><p>getCurrentPosition() // 获取当前的位置信息</p>
</li>
<li><p>watchPosition() // 监视位置变化，和1参数一样</p>
</li>
<li><p>clearWatch() //清楚位置监视</p>
</li>
<li><p>getCurrentPosition(s,e,p)</p>
</li>
</ol>
<ul>
<li>success  回调（必须）</li>
<li>error  回调</li>
<li>options  参数</li>
<li>需要翻墙</li>
</ul>
<h2 id="Geoposition"><a href="#Geoposition" class="headerlink" title="Geoposition"></a>Geoposition</h2><p><img src="../image/h5-gpos.png" alt=""></p>
<h2 id="PositionError对象"><a href="#PositionError对象" class="headerlink" title="PositionError对象"></a>PositionError对象</h2><ul>
<li>用户拒绝 code = 1</li>
<li>获取不到 code = 2</li>
<li>链接超时 code = 3</li>
</ul>
<h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><ul>
<li>enableHighAccuracy 是否需要高精度位置默认false</li>
<li>timeout 单位ms 请求超时时间 默认infinity</li>
<li>maximumAge 单位ms，watchPosition方法则不停地取用户的地理位置信息，不停地更新用户的位置信息。位置信息过期时间 设置为0就无条件获取新的地理位置信息 默认0</li>
</ul>
<h2 id="watchPosition"><a href="#watchPosition" class="headerlink" title="watchPosition"></a>watchPosition</h2><ul>
<li>var id = geolocation.watchPosition(fu)用于注册监听器，在设备的地理位置发生改变的时候自动被调用</li>
<li>clearWatch(id) 使用clearWatch 清楚监听</li>
</ul>
<h2 id="devicemotion-监听加速度变化"><a href="#devicemotion-监听加速度变化" class="headerlink" title="devicemotion 监听加速度变化"></a>devicemotion 监听加速度变化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;devicemotion&apos;,function()&#123;</span><br><span class="line">    console.log(event);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="devicemotion-事件所包含的属性"><a href="#devicemotion-事件所包含的属性" class="headerlink" title="devicemotion 事件所包含的属性"></a>devicemotion 事件所包含的属性</h2><ol>
<li>accelerationIncludingGravity (包括重心引力，z轴方向加了9.8，在x，y方向上的值两者相同) 重力加速度</li>
<li>acceleration 重力加速度</li>
<li>rotationRate(alpha,beta,gamma)旋转速率</li>
<li>interval 获取的时间间隔<br><img src="../image/yaoyiyao.png" alt=""><br>均为只读属性</li>
</ol>
<h2 id="deviceorientation-监听设备在方向上的变化"><a href="#deviceorientation-监听设备在方向上的变化" class="headerlink" title="deviceorientation 监听设备在方向上的变化"></a>deviceorientation 监听设备在方向上的变化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;deviceorientation&apos;,function()&#123;</span><br><span class="line">    console.log(event);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li>alhpa 表示设备上沿z轴上的旋转角度，范围为0~360</li>
<li>beta 表示设备上在x轴上的旋转角度，范围为-180~180 它描述设备由前向后旋转的情况</li>
<li>gamma 表示设备在y轴上的旋转角度，范围为-90~90 它描述是设备由左向右旋转的情况</li>
<li>webkitCompassHeading 与正北方向的角度差值。正北为0度，正东为90度，正南为180度，正西为270度。因为0度是正北，所以叫指北针(ios)</li>
</ol>
<ul>
<li>css3画表盘，先将刻度线居中，在rotate旋转，字歪了在沿着z轴转回来，js中操作</li>
</ul>
<ol start="5">
<li>webkitCompassAccuracy 指北针的精确度，表示偏差为正负多少度。一般是10</li>
</ol>
<p><img src="../image/h5-xyz.png" alt=""></p>
<h2 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h2><ul>
<li>audio 音频</li>
<li>video 视频</li>
</ul>
<h2 id="音频-视频"><a href="#音频-视频" class="headerlink" title="音频/视频"></a>音频/视频</h2><ul>
<li>基础用法</li>
<li>属性</li>
<li>事件</li>
</ul>
<h2 id="audio元素和video元素"><a href="#audio元素和video元素" class="headerlink" title="audio元素和video元素"></a>audio元素和video元素</h2><p><code>&lt;audio id=&quot;audio&quot; src=&quot;./成都.mp3&quot;&gt;&lt;/audio&gt;</code><br><code>&lt;video id=&quot;video&quot; src=&quot;./成都.mp4&quot;&gt;&lt;/video&gt;</code></p>
<h2 id="一些属性"><a href="#一些属性" class="headerlink" title="一些属性"></a>一些属性</h2><ol>
<li>autoplay 自动播放<br><code>&lt;audio src=&quot;成都.mp3&quot; autoplay&gt;&lt;/audio&gt;</code></li>
<li>controls 设置控件<br><code>&lt;audio src=&quot;成都.mp3&quot; autoplay controls&gt;&lt;/audio&gt;</code></li>
<li>preload(none/metadata/auto) 预加载，规定是否在页面加载后载入视频</li>
</ol>
<ul>
<li>node 不需要加载数据</li>
<li>metadata 元数据 诸如时长、比特率、帧大小这样的原数据而不是媒体内容需要加载的</li>
<li>auto 浏览器应当加载它认为适量的媒体内容<br><code>&lt;audio src=&quot;成都.mp3&quot; autoplay controls preload=&quot;auto&quot;&gt;&lt;/audio&gt;</code></li>
</ul>
<ol start="4">
<li>loop 是否循环播放音/视频<br><code>&lt;audio src=&quot;成都.mp3&quot; autoplay controls loop preload=&quot;auto&quot;&gt;&lt;/audio&gt;</code></li>
<li>poster(video 独有) 当视频不可用，使用一张图片替代，否则是空白<br><code>&lt;video src=&quot;成都.mp4&quot; poster=&quot;封面.jpg&quot; controls&gt;&lt;/video&gt;</code></li>
</ol>
<h2 id="多类型资源"><a href="#多类型资源" class="headerlink" title="多类型资源"></a>多类型资源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio id=&quot;music&quot;&gt;</span><br><span class="line">    &lt;source src=&quot;成都.mp3&quot; type=&quot;audio/mpeg&quot;&gt;</span><br><span class="line">    &lt;source src=&quot;成都.ogg&quot; type=&quot;audio/ogg&quot;&gt;</span><br><span class="line">&lt;/audio&gt;</span><br></pre></td></tr></table></figure>
<h2 id="脚本化"><a href="#脚本化" class="headerlink" title="脚本化"></a>脚本化</h2><ul>
<li>var audio = document.getElementById(‘audio’);</li>
<li>var audio = new Audio(‘./laojie.mp3’)</li>
<li>var audio = document.createElement(‘video’)</li>
</ul>
<p>只能new Audio(),不能video，因为没有video这个函数</p>
<h2 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h2><p>controls/loop/preload/autoplay属性</p>
<ul>
<li>audio.controls = true;</li>
<li>audio.loop = ‘loop’;</li>
<li>audio.preload = ‘auto’;</li>
<li>audio.autoplay = true;<br>currentSrc 资源链接，媒体数据的url地址</li>
</ul>
<p>注意：window.onload</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li>play() 方法</li>
<li>pause() 方法</li>
<li>load() 方法<br>重新加载视频/音频元素，用于在更改来源或其他设置后对音频/视频元素进行更新</li>
</ol>
<h2 id="音量-volume属性"><a href="#音量-volume属性" class="headerlink" title="音量 volume属性"></a>音量 volume属性</h2><p>表示播放音量，介于0（静音）~1（最大音量）之间，默认1.将muted属于性设置为true则会进入静音模式，设置为false则会恢复之前指定的音量继续播放</p>
<p>超过范围会报错[0,1]</p>
<h2 id="播放速率-playbackRate"><a href="#播放速率-playbackRate" class="headerlink" title="播放速率 playbackRate"></a>播放速率 playbackRate</h2><p>用于指定媒体播放的速度。该属性值为1.0表示正常速度，大于1则表示“快进”，0~1之间表示“慢放”，负值表示回放。</p>
<p>每个浏览器实现的会有差别，具体看浏览器实现</p>
<h2 id="currentTime-duration属性"><a href="#currentTime-duration属性" class="headerlink" title="currentTime/duration属性"></a>currentTime/duration属性</h2><ul>
<li>currentTime 设置或返回音频/视频播放的当前位置</li>
<li>duration 返回当前音频/视频的时长（window.onload）</li>
<li>单位 秒</li>
</ul>
<h2 id="played-buffered-seekable"><a href="#played-buffered-seekable" class="headerlink" title="played/buffered/seekable"></a>played/buffered/seekable</h2><p>played属性返回已经播放（看过）的时间段，buffered属性返回当前已经缓冲的时间段，seekable属性则返回用户可以跳转的时间段。这三个属性都是TimeRanges对象，每个对象都有一个length属性以及start()和end()方法，length属性表示当前的一个时间段，start()与end()分别返回当前时间段的起始时间点和结束时间点（单位是秒，起始参数是0）</p>
<p>下面代码确定当前缓存内容的百分比：<br><code>var percent_loaded=Math.floor(song.buffered.end(0) / song.duration*100)</code></p>
<h2 id="paused-seeking-ended"><a href="#paused-seeking-ended" class="headerlink" title="paused/seeking/ended"></a>paused/seeking/ended</h2><p>这三个属性用来查询媒体播放器状态，paused为true表示播放器暂停。seeking为true表示播放器正在调到一个新的播放点，如果播放器播放完媒体并且停下来，则ended属性为true</p>
<p>作为了解</p>
<h2 id="canPlayType-方法"><a href="#canPlayType-方法" class="headerlink" title="canPlayType() 方法"></a>canPlayType() 方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = new Audio();</span><br><span class="line">if(a.canPlayType(&apos;audio/mp3&apos;))&#123;</span><br><span class="line">    a.src = &apos;./成都.mp3&apos;;</span><br><span class="line">    a.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h2><ul>
<li>play 开始播放触发</li>
<li>pause 暂停触发</li>
<li>loadedmetadata 浏览器获取完媒体的元数据触发</li>
<li>loadeddata 浏览器已经加载完当前帧数据，准备播放时触发，注意IE8</li>
<li>ended 当前播发结束后触发</li>
</ul>
<h2 id="readyState属性音频的当前就绪状态"><a href="#readyState属性音频的当前就绪状态" class="headerlink" title="readyState属性音频的当前就绪状态"></a>readyState属性音频的当前就绪状态</h2><p>表示音频元素的就绪转态：</p>
<ul>
<li>0 = HAVE_NOTHING 没有关于音频是否就绪的信息</li>
<li>1 = HAVE_METADATA 关于音频就绪的元数据</li>
<li>2 = HAVE_CURRENT_DATA 关于当前播放位置的数据是可用的，但没有足够的数据来播放下一帧/毫秒</li>
<li>3 = HAVE_FUTURE_DATA 当前及至少下一帧的数据是可用的</li>
<li>4 = HAVE_ENOUGH_DATA 可用数据足以开始播放</li>
</ul>
<h2 id="networkState属性返回音频的当前网络状态"><a href="#networkState属性返回音频的当前网络状态" class="headerlink" title="networkState属性返回音频的当前网络状态"></a>networkState属性返回音频的当前网络状态</h2><p>表示音频元素的当前网络状态：</p>
<ul>
<li>0 = NETWORK_EMPTY 音频尚未初始化</li>
<li>1 = NETWORK_IDLE 音频是活动的且已选取资源，但并未使用网络</li>
<li>2 = NETWORK_LOADING 浏览器正在下载数据</li>
<li>3 = NETWORK_NO_SOURCE 未找到音频来源</li>
</ul>
<h2 id="error-事件在音频-视频-audio-video-加载发生错误时触发"><a href="#error-事件在音频-视频-audio-video-加载发生错误时触发" class="headerlink" title="error 事件在音频/视频(audio/video)加载发生错误时触发"></a>error 事件在音频/视频(audio/video)加载发生错误时触发</h2><p><img src="../image/error.png" alt="error"></p>
<h2 id="drag-amp-drop-FileReader-Web-Socket"><a href="#drag-amp-drop-FileReader-Web-Socket" class="headerlink" title="drag &amp; drop  FileReader  Web Socket"></a>drag &amp; drop  FileReader  Web Socket</h2><h2 id="drag-amp-drop"><a href="#drag-amp-drop" class="headerlink" title="drag &amp; drop"></a>drag &amp; drop</h2><ul>
<li>常用于各种拖动操作中 (像电脑桌面拖拽的文件类似)</li>
<li>创建可拖动元素<br><code>&lt;div id=&quot;drag&quot; draggable=&quot;true&quot;&gt;&lt;/div&gt;</code></li>
</ul>
<h2 id="拖拽相关的事件"><a href="#拖拽相关的事件" class="headerlink" title="拖拽相关的事件"></a>拖拽相关的事件</h2><p><img src="../image/drag.png" alt="drag"></p>
<h2 id="DragEvent-事件对象"><a href="#DragEvent-事件对象" class="headerlink" title="DragEvent 事件对象"></a>DragEvent 事件对象</h2><ul>
<li>传值</li>
</ul>
<p><code>e.dataTransfer.setData(&quot;data&quot;,e.target.id)</code></p>
<ul>
<li>取值</li>
</ul>
<p><code>e.dataTransfer.getData(&quot;data&quot;)</code></p>
<p><img src="../image/h5-drop.png" alt="列表换位"></p>
<h2 id="使用拖拽上传文件"><a href="#使用拖拽上传文件" class="headerlink" title="使用拖拽上传文件"></a>使用拖拽上传文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ele.addEventListener(&apos;dragover&apos;, function(e)&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;,false);</span><br><span class="line">ele.addEventListener(&apos;drop&apos;,function(e)&#123;</span><br><span class="line">    //调用preventDefault() 来避免浏览器对数据的默认处理（drop事件的默认行为是以链接形式打开）</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    console.log(e);</span><br><span class="line">    var dt = e.dataTransfer;</span><br><span class="line">    var files = dt.files;</span><br><span class="line">    console.log(files);</span><br><span class="line">&#125;,false)</span><br></pre></td></tr></table></figure>
<h2 id="FileReader-用于读取文件"><a href="#FileReader-用于读取文件" class="headerlink" title="FileReader 用于读取文件"></a>FileReader 用于读取文件</h2><h3 id="FileReader-方法"><a href="#FileReader-方法" class="headerlink" title="FileReader() 方法"></a>FileReader() 方法</h3><p>abort() 终止读取</p>
<p>readAsBinaryString(file) 将文件读取为二进制编码</p>
<p>readAsDataURL(file) 将文件读取为DataURL编码</p>
<p>readAsText(file,[encoding]) 将文件读取为文本</p>
<p>readAsArrayBuffer(file) 将文件读取为arraybuffer</p>
<p>通过不同的方式读取文件</p>
<h3 id="FileReader-事件"><a href="#FileReader-事件" class="headerlink" title="FileReader 事件"></a>FileReader 事件</h3><p>onloadstart 读取开始是触发</p>
<p>onprogress 读取中</p>
<p>onloadend 读取完成触发，无论成功或失败</p>
<p>onload 文件读取成功完成时触发</p>
<p>onabort 中断时触发</p>
<p>onerror 出错时触发</p>
<h2 id="Web-Socket"><a href="#Web-Socket" class="headerlink" title="Web Socket"></a>Web Socket</h2><p>WebSocket 对象提供了一组 API，用于创建和管理WebSocket 连接，以及通过连接发送和接收数据</p>
<p>WebSocket 其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已。借用了HTTP的协议来完成握手</p>
<p><img src="../image/webscoket.png" alt="webscoket"></p>
<p><img src="../image/ws.png" alt="webscoket"></p>
<h2 id="产生原因："><a href="#产生原因：" class="headerlink" title="产生原因："></a>产生原因：</h2><ul>
<li>在HTTP/1.0中，默认非长链接大多实现为每个请求/响应交换使用新的连接</li>
<li>在HTTP/1.0中，默认长连接一个连接可用于一次或多次请求/响应交换</li>
<li>在HTTP/1.0中，服务端不能主动联系客户端，只能有客户端发起。</li>
<li>webSoket服务器和客户端均可主动发送数据</li>
</ul>
<h2 id="创建webSocket"><a href="#创建webSocket" class="headerlink" title="创建webSocket"></a>创建webSocket</h2><p>var Socket = new WebSocket(url);</p>
<p>‘ws://echo.websocket.org’(测试地址)</p>
<h2 id="Web-Socket-事件"><a href="#Web-Socket-事件" class="headerlink" title="Web Socket 事件"></a>Web Socket 事件</h2><p><img src="../image/socket1.png" alt="webscoket"></p>
<h2 id="Web-Socket-方法"><a href="#Web-Socket-方法" class="headerlink" title="Web Socket 方法"></a>Web Socket 方法</h2><ol>
<li>Socket.send()<br>send(data) 方法使用连接传输数据</li>
<li>Socket.close()<br>close() 方法用于终止任何现有连接</li>
</ol>
<h2 id="WebSocket-的优点"><a href="#WebSocket-的优点" class="headerlink" title="WebSocket 的优点"></a>WebSocket 的优点</h2><ul>
<li>客户端与服务端都可以主动传送数据给对方；</li>
<li>不用频率创建TCP请求及销毁请求，减少网络宽带资源的占用，同时也节省服务器资源</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/07/html5/" data-id="cjp18921d000mggns4jelorkx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2018/11/15/module/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          module
        
      </div>
    </a>
  
  
    <a href="/blog/2018/11/07/html5-SVG/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">&#39;html5-SVG&#39;</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/08/">August 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2018/11/28/Git/">Git</a>
          </li>
        
          <li>
            <a href="/blog/2018/11/27/ES6-Promise/">ES6-Promise</a>
          </li>
        
          <li>
            <a href="/blog/2018/11/27/ES6-class/">ES6-class</a>
          </li>
        
          <li>
            <a href="/blog/2018/11/26/ES6-五/">ES6(五)</a>
          </li>
        
          <li>
            <a href="/blog/2018/11/26/ES6-四/">ES6(四)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/blog/Cultural-and-art" class="mobile-nav-link">Cultural-and-art</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>



  </div>
</body>
</html>